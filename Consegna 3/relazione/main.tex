\documentclass[a4paper]{article}
\usepackage[italian]{babel}
\usepackage[left=2cm, right=2cm, bottom=2cm, top=2cm]{geometry}
\usepackage{csvsimple}
\usepackage[utf8]{inputenc}
\usepackage{float}
\usepackage{pdfpages}
\usepackage[scaled]{helvet}
\renewcommand\familydefault{\sfdefault} 
\usepackage{pgfplots}
\usepackage{pdflscape}
%opening
\title{Relazione laboratorio Algoritmi Avanzati}
\author{Magarotto Francesco\\Muraro Enrico\\Piva Giulio}

\begin{document}
\begin{titlepage}
  \vspace*{5cm}
  \begin{center}
    \Large\bfseries
    Relazione di laboratorio
  \end{center}
  \begin{center}
    \large
    Corso di Algoritmi Avanzati\\
    Laurea Magistrale in Informatica\\A.A. 2019-2020
  \end{center}
  \vspace{4cm plus 1fill}
  \begin{flushleft}
    \large
    Magarotto Francesco - 1236594\\Muraro Enrico - 1238899 \\Piva Giulio - 1242455
  \end{flushleft}
\end{titlepage}
\newpage

\input{introduzione}

\section{Tabella dei risultati}
\begin{figure}[H]
	\centering
	\includegraphics[width=17cm]{tabellapdf}
	\label{fig:tabellapdf}
\end{figure}

\section{Domanda 1}
\begin{figure}[H]
	\centering
	\includegraphics[width=17cm]{fullcontraction}
	\label{fig:fullcontraction}
\end{figure}
Il tempo medio per eseguire una Full-Contraction in base al numero di vertici rimane abbastanza vicino alla sua complessità asintotica

\section{Domanda 2}
\begin{figure}[H]
	\centering
	\includegraphics[width=17cm]{tempoesecvsnumnodi}
	\label{fig:tempoesecvsnumnodi}
\end{figure}
Il numero di ripetizioni scelto è $k = (n^2)/2 * log(n)$ dove $n$ è il numero di vertici, in modo da garantire che la probabilità di sbagliare sia minore o uguale a $1/n$.
Il tempo di esecuzione dell'algoritmo segue l'andamento della sua complessità asintotica, ma per i grafi più grandi è stato necessario introdurre un timeout di 60 secondi per mantenere un tempo di esecuzione totale ragionevole.

\section{Domanda 3}
\begin{figure}[H]
	\begin{center}
	\includegraphics[width=17cm]{discoveryvsfulltime}
	\label{fig:discoveryvsfulltime}
\end{center}
\end{figure}
Il grafico mette in relazione il discovery time vs il tempo impiegato applicando la scala logaritmica se il valore del tempo è maggiore di 0, altrimenti lasciamo zero. Come si può evincere dal grafico, fino a 10 nodi il tempo di esecuzione è brevissimo, e le due misurazioni sono equivalenti. È importante evidenziare che all'aumentare del numero di vertici le due misurazioni aumentano. Come evidenziato dal discovery time, nonostante il timeout, l'algoritmo riesce comunque a trovare il taglio minimo molto prima, ovviamente l'interruzione dell'esecuzione non permette di eseguire tutti i confronti necessari, ma il fattore d'interesse è garantire un'alta probabilità di successo in relazione al risultato ritornato.


\section{Domanda 4}
Come si può vedere nella tabella dei risultati nella sezione 2 il taglio ottenuto dall'algoritmo è esattamente il taglio minimo atteso. Questo perché, anche nelle istanze più grandi del dataset, l'algoritmo ha trovato la soluzione ottima prima del timeout di 60 secondi che abbiamo imposto. L'errore relativo è quindi 0 per ogni grafo.

\section{Conclusioni}
L'algoritmo risulta molto efficace a risolvere il problema del minimum cut nonostante la sua semplicità. È interessante notare che il discovery time in genere è molto più breve del tempo di esecuzione totale, e che le iterazioni aggiuntive servono semplicemente a garantire che il risultato sia giusto con alta probabilità. Infatti, anche le istanze da 200 vertici hanno ritornato il minimum cut nonostante siano state interrotte molto prima che l'algoritmo completasse tutte le iterazioni. Ovviamente imporre un timeout troppo piccolo riduce drasticamente la probabilità di successo, al punto di rendere l'algoritmo inaffidabile e poco utile per i grafi più grandi.

\end{document}
